---
title: "Statics"
format: html
author: "Deng Zhaoguo"
date: "`r Sys.Date()`"
self-contained: true
toc: true       # 显示目录
toc-depth: 5    # 显示三级标题
execute:
  eval: TRUE
  echo: TRUE
  warning: FALSE
  message: FALSE
---

# load

```{r}
library("openxlsx")
library('reshape2')
library('ggplot2')
library('dplyr')
```

# chisq test

```{r}
observed <- c(69, 68)    
expected_ratio <- c(1, 1) 

test_result <- chisq.test(
  x = observed,           
  p = expected_ratio/sum(expected_ratio)
)

print(test_result)

```

# t.test

```{r}
# Read data
measure <- read.xlsx("2024.4.15-DR5-S2S3.xlsx", sheet = 2)
df <- measure[, 3:4] %>% melt()
df <- df[!is.na(df[,2]), ]
colnames(df) <- c('sample', 'value')
df$value <- df$value/median(df$value)

# remove outlier for t-test
df_markOutiler <- df %>%
  group_by(sample) %>%
  mutate(is_outlier = value < (quantile(value, 0.25) - 1.5*IQR(value)) |
           value > (quantile(value, 0.75) + 1.5*IQR(value))) %>%
  ungroup()
```

```{r}
# t-test for all data
t_test_res <- t.test(value ~ sample, data = df_markOutiler, var.equal=T)
print(t_test_res)

```

```{r}
# t-test without outlier
t_test_res <- t.test(value ~ sample, data = filter(df_markOutiler, !is_outlier), var.equal=T)
print(t_test_res)

```

# Multiple comparison 多重比较

## ANOVA + post hoc: TukeyHSD 比较均值，再事后检验

```{r}
# toy data
df <- data.frame(
  group = rep(c("nonS", "LAZY", "17-87", "D"), each=7),
  value = c(5,6,5,7,6,2,1 , 7,8,7,9,6,21,23, 8,9,7,10,8,10,19, 10,11,9,12,10,12,15)
)

df$group <- factor(df$group)
```

ANOVA

```{r}
fit <- aov(value ~ group, data = df)
summary(fit)
```

TukeyHSD，为了方便请安装 agricolae

```{r}
#install.packages('agricolae')
library(agricolae)

hsd <- HSD.test(fit, "group", group=TRUE)
print(hsd$groups)

# Prepare significance level table for plotting
sigLevel <- hsd$groups
sigLevel$group <- rownames(sigLevel)
colnames(sigLevel) <- c("mean", "levels", "group")
```


箱线图（其他图都行，+ geom_text 都是一样的）

```{r}
# Visualization parameters
bar_width   <- 0.35
jitter_width <- 0.05
dodge_width <- 0.5

# Base plot: boxplot + jittered points
p <- ggplot(df, aes(x = group, y = value, fill = group)) +
  geom_boxplot(
    #outlier.shape = NA,                # hide outliers
    width = bar_width,
    position = position_dodge(width = dodge_width)
  ) +
  geom_point(
    size = 1,
    shape = 16,
    position = position_jitterdodge(
      jitter.width = jitter_width,
      dodge.width = dodge_width
    )
  ) +
  theme_classic() +
  scale_fill_manual(values = c('#F8766D', '#00BD57', 'blue', 'yellow'))

print(p)
```

加上显著性水平, 其实很简单就是有一个数据结构，也是 group, levels的结构

```{r}
# Add significance letters 
p <- p + geom_text(
  data = sigLevel,
  aes(x = group, y = max(df$value) + 1, label = levels),
  vjust = 0
)

print(p)

```


## ANOVA + post hoc: Dunnett 这个是明确对照组的，使用 multcomp 包

```{r}
#install.packages('multcomp')
library(multcomp)

df <- data.frame(
  group = rep(c("nonS", "LAZY", "17_87", "D"), each=7),
  value = c(5,6,5,7,6,2,1 , 7,8,7,9,6,21,23, 8,9,7,10,8,10,19, 10,11,9,12,10,12,15)
)

```

设置对照组

```{r}
control = "nonS"

df$group <- relevel(factor(df$group), ref = control)
```

ANOVA

```{r}
fit <- aov(value ~ group, data = df)
```

Dunnett t-test

```{r}
dunnett <- glht(fit, linfct = mcp(group = "Dunnett"))
summary_dunnett <- summary(dunnett)
print(summary_dunnett)
```

把结果里的 pval 提取出来并重命名列，加入 ”对照-NA“ 列

```{r}

contrasts <- names(summary_dunnett$test$coefficients)     # e.g. "B - A"

group_names <- sub(' - .*',"",contrasts)

pvals     <- summary_dunnett$test$pvalues

# Build result table
sigLevel <- data.frame(
  group = c (control,group_names),
  p.val = c(NA, summary_dunnett$test$pvalues )
)

sigLevel$stars <- as.character(cut (sigLevel$p.val,
                       breaks = c(-Inf, 0.001, 0.01, 0.05, Inf),
                       labels = c("***", "**", "*", "ns")))

# don't draw anything on control group
sigLevel$stars[is.na(sigLevel$stars)]=c("")
```

```{r}
# Visualization parameters
bar_width   <- 0.35
jitter_width <- 0.05
dodge_width <- 0.5

# Base plot: boxplot + jittered points
p <- ggplot(df, aes(x = group, y = value, fill = group)) +
  geom_boxplot(
    #outlier.shape = NA,                # hide outliers
    width = bar_width,
    position = position_dodge(width = dodge_width)
  ) +
  geom_point(
    size = 1,
    shape = 16,
    position = position_jitterdodge(
      jitter.width = jitter_width,
      dodge.width = dodge_width
    )
  ) +
  theme_classic() +
  scale_fill_manual(values = c('#F8766D', '#00BD57', 'blue', 'yellow'))

print(p)
```

```{r}
p + geom_text(
  data = sigLevel,
  aes(x = group, y = max(df$value) + 1, label = stars),
  vjust = 0
)
```

## 更广泛的校正（不止是均值，各种<多重>相关性检验之后也可以校正 p value）应该用的最多的是BH （比如 RNASeq等组学），最严格的是直接除以test数目的 bonferroni（GWAS）

```{r eval=FALSE}
# Controls FWER 
p.adjust(pvalues,method="bonferroni") 

# control FWER by hochberg
p.adjust(pvalues,method="hochberg")

# Controls FDR 
p.adjust(pvalues,method="BH") 
p.adjust(pvalues,method="BY")
```

![](images/Snipaste_2025-09-24_19-25-50.jpg)

Case: LAZY回补line，先 KS test 计算各个角度分布之间的 pvalue, 再用 bonferroni 校正

```{r eval=FALSE}
nlen=7
p=vector(length=(nlen-1))
for (j in 2:nlen){
  i = 1
  p[j-1]=ks.test(mydata[,i],mydata[,j])$p.value
}

padj = p.adjust(p,method = "bonferroni")
padj
```
